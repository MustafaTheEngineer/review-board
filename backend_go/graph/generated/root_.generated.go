// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/MustafaTheEngineer/review_board/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Item() ItemResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Tag() TagResolver
	User() UserResolver
}

type DirectiveRoot struct {
	CheckIfConfirmed   func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	CheckUsername      func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	ValidateEmail      func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	ValidateItemAmount func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	ValidateItemTags   func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	ValidateItemTitle  func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	ValidatePassword   func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	ValidateToken      func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	ValidateUsername   func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
}

type ComplexityRoot struct {
	ConfirmUserResponse struct {
		Message func(childComplexity int) int
		User    func(childComplexity int) int
	}

	CreateItemResponse struct {
		Item func(childComplexity int) int
		Tags func(childComplexity int) int
	}

	Item struct {
		Amount      func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Status      func(childComplexity int) int
		Title       func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Mutation struct {
		ConfirmUser  func(childComplexity int, input model.ConfirmUserInput) int
		CreateItem   func(childComplexity int, input model.CreateItemRequest) int
		RegisterUser func(childComplexity int, input model.NewUser) int
		SetUsername  func(childComplexity int, username string) int
		SignIn       func(childComplexity int, input model.SignInInput) int
	}

	Query struct {
		IsUsernameTaken  func(childComplexity int, username string) int
		Tags             func(childComplexity int, query *model.TagsInput) int
		UserConfirmed    func(childComplexity int) int
		UserHaveUsername func(childComplexity int) int
		ValidateToken    func(childComplexity int) int
	}

	RegisterUserResponse struct {
		Message func(childComplexity int) int
		User    func(childComplexity int) int
	}

	SetUsernameResponse struct {
		Message func(childComplexity int) int
		User    func(childComplexity int) int
	}

	SignInResponse struct {
		Message func(childComplexity int) int
		User    func(childComplexity int) int
	}

	Tag struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	TokenValidationResponse struct {
		User func(childComplexity int) int
	}

	User struct {
		Blocked   func(childComplexity int) int
		Confirmed func(childComplexity int) int
		Email     func(childComplexity int) int
		Role      func(childComplexity int) int
		Username  func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "ConfirmUserResponse.message":
		if e.complexity.ConfirmUserResponse.Message == nil {
			break
		}

		return e.complexity.ConfirmUserResponse.Message(childComplexity), true

	case "ConfirmUserResponse.user":
		if e.complexity.ConfirmUserResponse.User == nil {
			break
		}

		return e.complexity.ConfirmUserResponse.User(childComplexity), true

	case "CreateItemResponse.item":
		if e.complexity.CreateItemResponse.Item == nil {
			break
		}

		return e.complexity.CreateItemResponse.Item(childComplexity), true

	case "CreateItemResponse.tags":
		if e.complexity.CreateItemResponse.Tags == nil {
			break
		}

		return e.complexity.CreateItemResponse.Tags(childComplexity), true

	case "Item.amount":
		if e.complexity.Item.Amount == nil {
			break
		}

		return e.complexity.Item.Amount(childComplexity), true

	case "Item.createdAt":
		if e.complexity.Item.CreatedAt == nil {
			break
		}

		return e.complexity.Item.CreatedAt(childComplexity), true

	case "Item.description":
		if e.complexity.Item.Description == nil {
			break
		}

		return e.complexity.Item.Description(childComplexity), true

	case "Item.id":
		if e.complexity.Item.ID == nil {
			break
		}

		return e.complexity.Item.ID(childComplexity), true

	case "Item.status":
		if e.complexity.Item.Status == nil {
			break
		}

		return e.complexity.Item.Status(childComplexity), true

	case "Item.title":
		if e.complexity.Item.Title == nil {
			break
		}

		return e.complexity.Item.Title(childComplexity), true

	case "Item.updatedAt":
		if e.complexity.Item.UpdatedAt == nil {
			break
		}

		return e.complexity.Item.UpdatedAt(childComplexity), true

	case "Mutation.confirmUser":
		if e.complexity.Mutation.ConfirmUser == nil {
			break
		}

		args, err := ec.field_Mutation_confirmUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmUser(childComplexity, args["input"].(model.ConfirmUserInput)), true

	case "Mutation.createItem":
		if e.complexity.Mutation.CreateItem == nil {
			break
		}

		args, err := ec.field_Mutation_createItem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateItem(childComplexity, args["input"].(model.CreateItemRequest)), true

	case "Mutation.registerUser":
		if e.complexity.Mutation.RegisterUser == nil {
			break
		}

		args, err := ec.field_Mutation_registerUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterUser(childComplexity, args["input"].(model.NewUser)), true

	case "Mutation.setUsername":
		if e.complexity.Mutation.SetUsername == nil {
			break
		}

		args, err := ec.field_Mutation_setUsername_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetUsername(childComplexity, args["username"].(string)), true

	case "Mutation.signIn":
		if e.complexity.Mutation.SignIn == nil {
			break
		}

		args, err := ec.field_Mutation_signIn_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SignIn(childComplexity, args["input"].(model.SignInInput)), true

	case "Query.isUsernameTaken":
		if e.complexity.Query.IsUsernameTaken == nil {
			break
		}

		args, err := ec.field_Query_isUsernameTaken_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsUsernameTaken(childComplexity, args["username"].(string)), true

	case "Query.tags":
		if e.complexity.Query.Tags == nil {
			break
		}

		args, err := ec.field_Query_tags_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tags(childComplexity, args["query"].(*model.TagsInput)), true

	case "Query.userConfirmed":
		if e.complexity.Query.UserConfirmed == nil {
			break
		}

		return e.complexity.Query.UserConfirmed(childComplexity), true

	case "Query.userHaveUsername":
		if e.complexity.Query.UserHaveUsername == nil {
			break
		}

		return e.complexity.Query.UserHaveUsername(childComplexity), true

	case "Query.validateToken":
		if e.complexity.Query.ValidateToken == nil {
			break
		}

		return e.complexity.Query.ValidateToken(childComplexity), true

	case "RegisterUserResponse.message":
		if e.complexity.RegisterUserResponse.Message == nil {
			break
		}

		return e.complexity.RegisterUserResponse.Message(childComplexity), true

	case "RegisterUserResponse.user":
		if e.complexity.RegisterUserResponse.User == nil {
			break
		}

		return e.complexity.RegisterUserResponse.User(childComplexity), true

	case "SetUsernameResponse.message":
		if e.complexity.SetUsernameResponse.Message == nil {
			break
		}

		return e.complexity.SetUsernameResponse.Message(childComplexity), true

	case "SetUsernameResponse.user":
		if e.complexity.SetUsernameResponse.User == nil {
			break
		}

		return e.complexity.SetUsernameResponse.User(childComplexity), true

	case "SignInResponse.message":
		if e.complexity.SignInResponse.Message == nil {
			break
		}

		return e.complexity.SignInResponse.Message(childComplexity), true

	case "SignInResponse.user":
		if e.complexity.SignInResponse.User == nil {
			break
		}

		return e.complexity.SignInResponse.User(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "TokenValidationResponse.user":
		if e.complexity.TokenValidationResponse.User == nil {
			break
		}

		return e.complexity.TokenValidationResponse.User(childComplexity), true

	case "User.blocked":
		if e.complexity.User.Blocked == nil {
			break
		}

		return e.complexity.User.Blocked(childComplexity), true

	case "User.confirmed":
		if e.complexity.User.Confirmed == nil {
			break
		}

		return e.complexity.User.Confirmed(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputConfirmUserInput,
		ec.unmarshalInputCreateItemRequest,
		ec.unmarshalInputNewUser,
		ec.unmarshalInputSignInInput,
		ec.unmarshalInputTagsInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../item.graphqls", Input: `directive @validateItemTitle on FIELD_DEFINITION
directive @validateItemAmount on FIELD_DEFINITION
directive @validateItemTags on FIELD_DEFINITION

enum ItemStatus {
  NEW
  IN_REVIEW
  APPROVED
  REJECTED
}

type Item {
  id: ID!
  title: String!
  description: String
  amount: String!
  status: ItemStatus!
  createdAt: Date!
  updatedAt: Date!
}

extend type Mutation {
  createItem(input: CreateItemRequest!): CreateItemResponse
    @validateItemTags
    @validateItemAmount
    @validateItemTitle
    @checkUsername
    @checkIfConfirmed
    @validateToken
}

input CreateItemRequest {
  title: String!
  description: String
  amount: Float!
  tags: [String!]!
}

type CreateItemResponse {
  item: Item!
  tags: [String!]!
}
`, BuiltIn: false},
	{Name: "../schema.graphqls", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

scalar Date
scalar Any
scalar UUID

directive @validateToken on FIELD_DEFINITION

type Query {
  validateToken: TokenValidationResponse! @validateToken
}

type TokenValidationResponse {
  user: User!
}
`, BuiltIn: false},
	{Name: "../tag.graphqls", Input: `type Tag {
  id: ID!
  name: String!
}

extend type Query {
  tags(query: TagsInput): [Tag!]!
    @checkUsername
    @checkIfConfirmed
    @validateToken
}

input TagsInput {
  limit: Int
  offset: Int
  like: String
}
`, BuiltIn: false},
	{Name: "../user.graphqls", Input: `type User {
  email: String!
  username: String
  confirmed: Boolean!
  blocked: Boolean!
  role: String!
}

directive @validateEmail on FIELD_DEFINITION
directive @validatePassword on FIELD_DEFINITION
directive @checkUsername on FIELD_DEFINITION
directive @checkIfConfirmed on FIELD_DEFINITION
directive @validateUsername on FIELD_DEFINITION

extend type Query {
  userConfirmed: Boolean! @validateToken
  userHaveUsername: Boolean! @validateToken
  isUsernameTaken(username: String!): Boolean! @checkIfConfirmed @validateToken
}

type Mutation {
  registerUser(input: NewUser!): RegisterUserResponse!
    @validateEmail
    @validatePassword
  signIn(input: SignInInput!): SignInResponse! @validateEmail @validatePassword
  confirmUser(input: ConfirmUserInput!): ConfirmUserResponse!
    @validateToken
  setUsername(username: String!): SetUsernameResponse!
    @validateUsername
    @checkIfConfirmed
    @validateToken
}

input NewUser {
  email: String!
  password: String!
}

type RegisterUserResponse {
  message: String!
  user: User!
}

input SignInInput {
  email: String!
  password: String!
}

type SignInResponse {
  message: String!
  user: User!
}

input ConfirmUserInput {
  confirmationCode: String!
}

type ConfirmUserResponse {
  message: String!
  user: User!
}

type SetUsernameResponse {
  message: String!
  user: User!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
