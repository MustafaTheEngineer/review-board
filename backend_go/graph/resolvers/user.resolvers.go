package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"database/sql"
	"net/http"
	"time"

	"github.com/99designs/gqlgen/graphql"
	dbConfig "github.com/MustafaTheEngineer/review_board/config/db"
	graph "github.com/MustafaTheEngineer/review_board/graph/generated"
	"github.com/MustafaTheEngineer/review_board/graph/model"
	"github.com/MustafaTheEngineer/review_board/helpers"
	"github.com/MustafaTheEngineer/review_board/internal/database"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"golang.org/x/crypto/bcrypt"
)

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, input model.NewUser) (*model.RegisterUserResponse, error) {
	// Start a new transaction to ensure data integrity
	tx, err := dbConfig.DbCfg.SqlDb.Begin()

	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: "Failed to start transaction",
			Extensions: map[string]any{
				"code": http.StatusInternalServerError,
			},
		})
		return nil, err
	}
	defer tx.Rollback()

	qtx := dbConfig.DbCfg.Queries.WithTx(tx)

	dbUser, err := qtx.GetUserByEmail(ctx, input.Email)
	if err != nil {
		if err != sql.ErrNoRows {
			graphql.AddError(ctx, &gqlerror.Error{
				Path:    graphql.GetPath(ctx),
				Message: "Error while checking if user already exists",
				Extensions: map[string]any{
					"code": http.StatusInternalServerError,
				},
			})
		}
	} else {
		graphql.AddError(ctx, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: "User with this email already exists",
			Extensions: map[string]any{
				"code": http.StatusConflict,
			},
		})
		return nil, err
	}

	userID := uuid.New()
	verificationCode, err := helpers.GenerateVerificationCode()

	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: "Error while generating verification code",
			Extensions: map[string]any{
				"code": http.StatusInternalServerError,
			},
		})
		return nil, err
	}

	passwordHash, err := bcrypt.GenerateFromPassword([]byte(input.Password), 14)

	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: "Error while hashing password",
			Extensions: map[string]any{
				"code": http.StatusInternalServerError,
			},
		})
		return nil, err
	}

	dbUser, err = qtx.RegisterUser(ctx, database.RegisterUserParams{
		ID:           userID,
		Email:        input.Email,
		PasswordHash: string(passwordHash),
		VerificationCode: sql.NullString{
			String: verificationCode,
			Valid:  true,
		},
		VerificationCodeExpiry: sql.NullTime{
			Time:  time.Now().Add(time.Hour * 24),
			Valid: true,
		},
		Provider: "email",
	})

	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: "Error while registering user",
			Extensions: map[string]any{
				"code": http.StatusInternalServerError,
			},
		})
		return nil, err
	}

	jwtInfo, err := helpers.GenerateJWT(userID.String(), string(dbUser.Role))

	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: "Error while generating JWT",
			Extensions: map[string]any{
				"code": http.StatusInternalServerError,
			},
		})
		return nil, err
	}

	if w, ok := ctx.Value(helpers.ResponseWriterKey).(http.ResponseWriter); ok {
		http.SetCookie(w, &http.Cookie{
			Name:     "auth-token",
			Value:    jwtInfo,
			HttpOnly: true,
			Path:     "/",
			SameSite: http.SameSiteLaxMode,
			// Secure: true, // Open in production environment
		})
	} else {
		graphql.AddError(ctx, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: "Error while setting cookie",
			Extensions: map[string]any{
				"code": http.StatusInternalServerError,
			},
		})
		return nil, err
	}

	return &model.RegisterUserResponse{
		Message: "User registered successfully",
		User:    &dbUser,
	}, tx.Commit()
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.SignInInput) (*model.SignInResponse, error) {
	dbUser, err := dbConfig.DbCfg.Queries.GetUserByEmail(ctx, input.Email)

	if err != nil {
		if err != sql.ErrNoRows {
			graphql.AddError(ctx, &gqlerror.Error{
				Path:    graphql.GetPath(ctx),
				Message: "Error while checking if user already exists",
				Extensions: map[string]any{
					"code": http.StatusInternalServerError,
				},
			})
			return nil, err
		} else {
			graphql.AddError(ctx, &gqlerror.Error{
				Path:    graphql.GetPath(ctx),
				Message: "User not found",
				Extensions: map[string]any{
					"code": http.StatusNotFound,
				},
			})
			return nil, err
		}
	}

	if err := bcrypt.CompareHashAndPassword([]byte(dbUser.PasswordHash), []byte(input.Password)); err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: "Invalid password",
			Extensions: map[string]any{
				"code": http.StatusUnauthorized,
			},
		})
		return nil, err
	}

	jwtInfo, err := helpers.GenerateJWT(dbUser.ID.String(), string(dbUser.Role))

	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: "Error while generating JWT",
			Extensions: map[string]any{
				"code": http.StatusInternalServerError,
			},
		})
		return nil, err
	}

	if w, ok := ctx.Value(helpers.ResponseWriterKey).(http.ResponseWriter); ok {
		http.SetCookie(w, &http.Cookie{
			Name:     "auth-token",
			Value:    jwtInfo,
			HttpOnly: true,
			Path:     "/",
			SameSite: http.SameSiteLaxMode,
			// Secure: true, // Open in production environment
		})
	} else {
		graphql.AddError(ctx, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: "Error while setting cookie",
			Extensions: map[string]any{
				"code": http.StatusInternalServerError,
			},
		})
		return nil, err
	}

	return &model.SignInResponse{
		Message: "User registered successfully",
		User:    &dbUser,
	}, err
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (string, error) {
	return "trial", nil
}

// Username is the resolver for the username field.
func (r *userResolver) Username(ctx context.Context, obj *database.User) (*string, error) {
	if obj.Username.Valid {
		return &obj.Username.String, nil
	}
	return nil, nil
}

// Role is the resolver for the role field.
func (r *userResolver) Role(ctx context.Context, obj *database.User) (string, error) {
	return string(obj.Role), nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

// User returns graph.UserResolver implementation.
func (r *Resolver) User() graph.UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
