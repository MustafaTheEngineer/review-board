package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"database/sql"
	"fmt"
	"net/http"
	"time"

	"github.com/99designs/gqlgen/graphql"
	dbConfig "github.com/MustafaTheEngineer/review_board/config/db"
	graph "github.com/MustafaTheEngineer/review_board/graph/generated"
	"github.com/MustafaTheEngineer/review_board/graph/model"
	"github.com/MustafaTheEngineer/review_board/helpers"
	"github.com/MustafaTheEngineer/review_board/internal/database"
	"github.com/MustafaTheEngineer/review_board/types"
	goqu "github.com/doug-martin/goqu/v9"
	"github.com/doug-martin/goqu/v9/exp"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, input model.NewUser) (*model.RegisterUserResponse, error) {
	// Start a new transaction to ensure data integrity
	tx, err := dbConfig.DbCfg.SqlDb.Begin()

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Failed to start transaction", http.StatusInternalServerError)
		return nil, nil
	}
	defer tx.Rollback()

	qtx := dbConfig.DbCfg.Queries.WithTx(tx)

	dbUser, err := qtx.GetUserByEmail(ctx, input.Email)
	if err != nil {
		if err != sql.ErrNoRows {
			helpers.CreateGraphQLError(ctx, "Error while checking if user already exists", http.StatusInternalServerError)
		}
	} else {
		helpers.CreateGraphQLError(ctx, "User with this email already exists", http.StatusConflict)
		return nil, nil
	}

	userID := uuid.New()
	verificationCode, err := helpers.GenerateVerificationCode()

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while generating verification code", http.StatusInternalServerError)
		return nil, nil
	}

	passwordHash, err := bcrypt.GenerateFromPassword([]byte(input.Password), 14)

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while hashing password", http.StatusInternalServerError)
		return nil, nil
	}

	dbUser, err = qtx.RegisterUser(ctx, database.RegisterUserParams{
		ID:           userID,
		Email:        input.Email,
		PasswordHash: string(passwordHash),
		VerificationCode: sql.NullString{
			String: verificationCode,
			Valid:  true,
		},
		VerificationCodeExpiry: sql.NullTime{
			Time:  time.Now().Add(time.Hour * 24),
			Valid: true,
		},
		Provider: "email",
	})

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while registering user", http.StatusInternalServerError)
		return nil, nil
	}

	jwtInfo, err := helpers.GenerateJWT(userID.String(), string(dbUser.Role))

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while generating JWT", http.StatusInternalServerError)
		return nil, nil
	}

	if w, ok := ctx.Value(helpers.ResponseWriterKey).(http.ResponseWriter); ok {
		http.SetCookie(w, &http.Cookie{
			Name:     "auth_token",
			Value:    jwtInfo,
			HttpOnly: true,
			Path:     "/",
			SameSite: http.SameSiteLaxMode,
			// Secure: true, // Open in production environment
		})
	} else {
		helpers.CreateGraphQLError(ctx, "Error while setting cookie", http.StatusInternalServerError)
		return nil, nil
	}

	return &model.RegisterUserResponse{
		Message: "User registered successfully",
		User:    &dbUser,
	}, tx.Commit()
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.SignInInput) (*model.SignInResponse, error) {
	dbUser, err := dbConfig.DbCfg.Queries.GetUserByEmail(ctx, input.Email)

	if err != nil {
		if err != sql.ErrNoRows {
			helpers.CreateGraphQLError(ctx, "Error while checking if user already exists", http.StatusInternalServerError)
			return nil, nil
		} else {
			helpers.CreateGraphQLError(ctx, "User not found", http.StatusNotFound)
			return nil, nil
		}
	}

	if err := bcrypt.CompareHashAndPassword([]byte(dbUser.PasswordHash), []byte(input.Password)); err != nil {
		helpers.CreateGraphQLError(ctx, "Invalid password", http.StatusUnauthorized)
		return nil, nil
	}

	jwtInfo, err := helpers.GenerateJWT(dbUser.ID.String(), string(dbUser.Role))

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while generating JWT", http.StatusInternalServerError)
		return nil, nil
	}

	if w, ok := ctx.Value(helpers.ResponseWriterKey).(http.ResponseWriter); ok {
		http.SetCookie(w, &http.Cookie{
			Name:     "auth_token",
			Value:    jwtInfo,
			HttpOnly: true,
			Path:     "/",
			SameSite: http.SameSiteLaxMode,
			// Secure: true, // Open in production environment
		})
	} else {
		helpers.CreateGraphQLError(ctx, "Error while setting cookie", http.StatusInternalServerError)
		return nil, nil
	}

	return &model.SignInResponse{
		Message: "User registered successfully",
		User:    &dbUser,
	}, nil
}

// ConfirmUser is the resolver for the confirmUser field.
func (r *mutationResolver) ConfirmUser(ctx context.Context, input model.ConfirmUserInput) (*model.ConfirmUserResponse, error) {
	code := graphql.GetOperationContext(ctx).Variables["input"].(map[string]any)["confirmationCode"].(string)
	err := helpers.V.VarWithKey("code", code, "len=6")
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Invalid confirmation code", http.StatusBadRequest)
		return nil, nil
	}

	userContext, ok := ctx.Value(types.UserContextKey).(types.UserContext)
	if !ok {
		helpers.CreateGraphQLError(ctx, "Username check requires authentication", http.StatusUnauthorized)
		return nil, nil
	}

	user, err := dbConfig.DbCfg.Queries.ConfirmUser(ctx, database.ConfirmUserParams{
		ID:       userContext.User.ID,
		Provider: "email",
		VerificationCode: sql.NullString{
			String: input.ConfirmationCode,
			Valid:  true,
		},
	})
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Invalid confirmation code", http.StatusBadRequest)
		return nil, nil
	}

	return &model.ConfirmUserResponse{
		Message: "User confirmed successfully",
		User:    &user,
	}, nil
}

// SetUsername is the resolver for the setUsername field.
func (r *mutationResolver) SetUsername(ctx context.Context, username string) (*model.SetUsernameResponse, error) {
	userContext, ok := ctx.Value(types.UserContextKey).(types.UserContext)
	if !ok {
		helpers.CreateGraphQLError(ctx, "Username check requires authentication", http.StatusUnauthorized)
		return nil, nil
	}

	dbUser, err := dbConfig.DbCfg.Queries.SetUserUsername(ctx, database.SetUserUsernameParams{
		ID: userContext.User.ID,
		Username: sql.NullString{
			String: username,
			Valid:  true,
		},
	})
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while setting username", http.StatusInternalServerError)
		return nil, nil
	}

	return &model.SetUsernameResponse{
		Message: "Username set successfully",
		User:    &dbUser,
	}, nil
}

// UserConfirmed is the resolver for the userConfirmed field.
func (r *queryResolver) UserConfirmed(ctx context.Context) (bool, error) {
	userContext, ok := ctx.Value(types.UserContextKey).(types.UserContext)
	if !ok {
		helpers.CreateGraphQLError(ctx, "User confirmation requires authentication", http.StatusUnauthorized)
		return false, nil
	}

	return userContext.User.Confirmed, nil
}

// UserHaveUsername is the resolver for the userHaveUsername field.
func (r *queryResolver) UserHaveUsername(ctx context.Context) (bool, error) {
	userContext, ok := ctx.Value(types.UserContextKey).(types.UserContext)
	if !ok {
		helpers.CreateGraphQLError(ctx, "Username check requires authentication", http.StatusUnauthorized)
		return false, nil
	}
	return userContext.User.Username.Valid, nil
}

// IsUsernameTaken is the resolver for the isUsernameTaken field.
func (r *queryResolver) IsUsernameTaken(ctx context.Context, username string) (bool, error) {
	_, ok := ctx.Value(types.UserContextKey).(types.UserContext)
	if !ok {
		helpers.CreateGraphQLError(ctx, "Username check requires authentication", http.StatusUnauthorized)
		return true, nil
	}
	_, err := dbConfig.DbCfg.Queries.GetUserByUsername(ctx, sql.NullString{
		String: username,
		Valid:  true,
	})
	if err != nil {
		if err != sql.ErrNoRows {
			helpers.CreateGraphQLError(ctx, "Error while checking if username already exists", http.StatusInternalServerError)
			return true, nil
		} else {
			return false, nil
		}
	} else {
		return true, nil
	}
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, query *model.UsersInput) ([]*database.User, error) {
	queryTags := goqu.Select("email", "username").From("users")

	if query == nil {
		queryTags = queryTags.Limit(100)
	} else {
		expressions := make([]exp.Expression, 0)
		if query.UsernameLike != nil {
			expressions = append(expressions, goqu.C("username").ILike("%"+*query.UsernameLike+"%"))
		}
		if query.EmailLike != nil {
			expressions = append(expressions, goqu.C("email").ILike("%"+*query.EmailLike+"%"))
		}

		if len(expressions) > 0 {
			queryTags = queryTags.Where(goqu.Or(expressions...))
		}

		if query.Limit == nil {
			queryTags = queryTags.Limit(100)
		} else {
			queryTags = queryTags.Limit(uint(*query.Limit))
		}
		if query.Offset != nil {
			queryTags = queryTags.Offset(uint(*query.Offset))
		}
	}

	var users []*database.User
	querySQL, _, err := queryTags.ToSQL()
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while building SQL query", http.StatusInternalServerError)
		return nil, nil
	}

	fmt.Println(querySQL)

	dbUsers, err := dbConfig.DbCfg.SqlDb.Query(querySQL)
	if err != nil {
		helpers.CreateGraphQLError(ctx, err.Error(), http.StatusInternalServerError)
		return nil, nil
	}
	defer dbUsers.Close()

	for dbUsers.Next() {
		var user database.User
		err := dbUsers.Scan(
			&user.Username,
			&user.Email,
		)
		if err != nil {
			helpers.CreateGraphQLError(ctx, "Error while scanning tag", http.StatusInternalServerError)
			return nil, nil
		}
		users = append(users, &user)
	}

	return users, nil
}

// Username is the resolver for the username field.
func (r *userResolver) Username(ctx context.Context, obj *database.User) (*string, error) {
	if obj.Username.Valid {
		return &obj.Username.String, nil
	}
	return nil, nil
}

// Role is the resolver for the role field.
func (r *userResolver) Role(ctx context.Context, obj *database.User) (string, error) {
	return string(obj.Role), nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// User returns graph.UserResolver implementation.
func (r *Resolver) User() graph.UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
