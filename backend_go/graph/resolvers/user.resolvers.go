package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"database/sql"
	"net/http"
	"time"

	dbConfig "github.com/MustafaTheEngineer/review_board/config/db"
	graph "github.com/MustafaTheEngineer/review_board/graph/generated"
	"github.com/MustafaTheEngineer/review_board/graph/model"
	"github.com/MustafaTheEngineer/review_board/helpers"
	"github.com/MustafaTheEngineer/review_board/internal/database"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, input model.NewUser) (*model.RegisterUserResponse, error) {
	// Start a new transaction to ensure data integrity
	tx, err := dbConfig.DbCfg.SqlDb.Begin()

	if err != nil {
		return &model.RegisterUserResponse{
			Metadata: &model.APIResponse{
				Code:    http.StatusInternalServerError,
				Status:  model.RequestStatusError,
				Message: "Failed to start transaction",
			},
			User:  &database.User{},
			Token: "",
		}, nil
	}
	defer tx.Rollback()

	qtx := dbConfig.DbCfg.Queries.WithTx(tx)

	dbUser, err := qtx.GetUserByEmail(ctx, input.Email)
	if err != nil {
		if err != sql.ErrNoRows {
			return &model.RegisterUserResponse{
				Metadata: &model.APIResponse{
					Code:    http.StatusInternalServerError,
					Status:  model.RequestStatusError,
					Message: "Error while checking if user already exists",
				},
				User:  &database.User{},
				Token: "",
			}, nil
		}
	} else {
		return &model.RegisterUserResponse{
			Metadata: &model.APIResponse{
				Code:    http.StatusConflict,
				Status:  model.RequestStatusError,
				Message: "Email already registered",
			},
			User:  &database.User{},
			Token: "",
		}, nil
	}

	userID := uuid.New()
	verificationCode, err := helpers.GenerateVerificationCode()

	if err != nil {
		return &model.RegisterUserResponse{
			Metadata: &model.APIResponse{
				Code:    http.StatusInternalServerError,
				Status:  model.RequestStatusError,
				Message: "Error while generating verification code",
			},
			User:  &database.User{},
			Token: "",
		}, nil

	}

	passwordHash, err := bcrypt.GenerateFromPassword([]byte(input.Password), 14)

	if err != nil {
		return &model.RegisterUserResponse{
			Metadata: &model.APIResponse{
				Code:    http.StatusInternalServerError,
				Status:  model.RequestStatusError,
				Message: "Error while hashing password",
			},
			User:  &database.User{},
			Token: "",
		}, nil
	}

	dbUser, err = qtx.RegisterUser(ctx, database.RegisterUserParams{
		ID:           userID,
		Email:        input.Email,
		PasswordHash: string(passwordHash),
		VerificationCode: sql.NullString{
			String: verificationCode,
			Valid:  true,
		},
		VerificationCodeExpiry: sql.NullTime{
			Time:  time.Now().Add(time.Hour * 24),
			Valid: true,
		},
		Provider: "email",
	})

	if err != nil {
		return &model.RegisterUserResponse{
			Metadata: &model.APIResponse{
				Code:    http.StatusInternalServerError,
				Status:  model.RequestStatusError,
				Message: "Error while registering user",
			},
			User:  &database.User{},
			Token: "",
		}, nil
	}

	jwtInfo, err := helpers.GenerateJWT(userID.String(), string(dbUser.Role))

	if err != nil {
		return &model.RegisterUserResponse{
			Metadata: &model.APIResponse{
				Code:    http.StatusInternalServerError,
				Status:  model.RequestStatusError,
				Message: "Error while generating JWT",
			},
			User:  &database.User{},
			Token: "",
		}, nil
	}

	return &model.RegisterUserResponse{
		Metadata: &model.APIResponse{
			Code:    http.StatusOK,
			Status:  model.RequestStatusSuccess,
			Message: "User registered successfully.",
		},
		User:  &dbUser,
		Token: jwtInfo,
	}, tx.Commit()
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.SignInInput) (*model.SignInResponse, error) {
	dbUser, err := dbConfig.DbCfg.Queries.GetUserByEmail(ctx, input.Email)

	if err != nil {
		if err != sql.ErrNoRows {
			return &model.SignInResponse{
				Metadata: &model.APIResponse{
					Code:    http.StatusInternalServerError,
					Status:  model.RequestStatusError,
					Message: "Error while checking if user already exists",
				},
				User:  &database.User{},
				Token: "",
			}, nil
		} else {
			return &model.SignInResponse{
				Metadata: &model.APIResponse{
					Code:    http.StatusNotFound,
					Status:  model.RequestStatusError,
					Message: "User not found",
				},
				User:  &database.User{},
				Token: "",
			}, nil
		}
	}

	if err := bcrypt.CompareHashAndPassword([]byte(dbUser.PasswordHash), []byte(input.Password)); err != nil {
		return &model.SignInResponse{
			Metadata: &model.APIResponse{
				Code:    http.StatusUnauthorized,
				Status:  model.RequestStatusError,
				Message: "Invalid password",
			},
			User:  &database.User{},
			Token: "",
		}, nil
	}

	jwtInfo, err := helpers.GenerateJWT(dbUser.ID.String(), string(dbUser.Role))

	if err != nil {
		return &model.SignInResponse{
			Metadata: &model.APIResponse{
				Code:    http.StatusInternalServerError,
				Status:  model.RequestStatusError,
				Message: "Error while generating JWT",
			},
			User:  &database.User{},
			Token: "",
		}, nil
	}

	return &model.SignInResponse{
		Metadata: &model.APIResponse{
			Code:    http.StatusOK,
			Status:  model.RequestStatusSuccess,
			Message: "User registered successfully.",
		},
		User:  &dbUser,
		Token: jwtInfo,
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (string, error) {
	return "trial", nil
}

// Username is the resolver for the username field.
func (r *userResolver) Username(ctx context.Context, obj *database.User) (*string, error) {
	if obj.Username.Valid {
		return &obj.Username.String, nil
	}
	return nil, nil
}

// Role is the resolver for the role field.
func (r *userResolver) Role(ctx context.Context, obj *database.User) (string, error) {
	return string(obj.Role), nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

// User returns graph.UserResolver implementation.
func (r *Resolver) User() graph.UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
