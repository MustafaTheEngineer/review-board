package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"database/sql"
	"fmt"
	"net/http"
	"time"

	"github.com/99designs/gqlgen/graphql"
	dbConfig "github.com/MustafaTheEngineer/review_board/config/db"
	graph "github.com/MustafaTheEngineer/review_board/graph/generated"
	"github.com/MustafaTheEngineer/review_board/graph/model"
	"github.com/MustafaTheEngineer/review_board/helpers"
	"github.com/MustafaTheEngineer/review_board/internal/database"
	"github.com/MustafaTheEngineer/review_board/types"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, input model.NewUser) (*model.RegisterUserResponse, error) {
	// Start a new transaction to ensure data integrity
	tx, err := dbConfig.DbCfg.SqlDb.Begin()

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Failed to start transaction", http.StatusInternalServerError)
		return nil, nil
	}
	defer tx.Rollback()

	qtx := dbConfig.DbCfg.Queries.WithTx(tx)

	dbUser, err := qtx.GetUserByEmail(ctx, input.Email)
	if err != nil {
		if err != sql.ErrNoRows {
			helpers.CreateGraphQLError(ctx, "Error while checking if user already exists", http.StatusInternalServerError)
		}
	} else {
		helpers.CreateGraphQLError(ctx, "User with this email already exists", http.StatusConflict)
		return nil, nil
	}

	userID := uuid.New()
	verificationCode, err := helpers.GenerateVerificationCode()

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while generating verification code", http.StatusInternalServerError)
		return nil, nil
	}

	passwordHash, err := bcrypt.GenerateFromPassword([]byte(input.Password), 14)

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while hashing password", http.StatusInternalServerError)
		return nil, nil
	}

	dbUser, err = qtx.RegisterUser(ctx, database.RegisterUserParams{
		ID:           userID,
		Email:        input.Email,
		PasswordHash: string(passwordHash),
		VerificationCode: sql.NullString{
			String: verificationCode,
			Valid:  true,
		},
		VerificationCodeExpiry: sql.NullTime{
			Time:  time.Now().Add(time.Hour * 24),
			Valid: true,
		},
		Provider: "email",
	})

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while registering user", http.StatusInternalServerError)
		return nil, nil
	}

	jwtInfo, err := helpers.GenerateJWT(userID.String(), string(dbUser.Role))

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while generating JWT", http.StatusInternalServerError)
		return nil, nil
	}

	if w, ok := ctx.Value(helpers.ResponseWriterKey).(http.ResponseWriter); ok {
		http.SetCookie(w, &http.Cookie{
			Name:     "auth_token",
			Value:    jwtInfo,
			HttpOnly: true,
			Path:     "/",
			SameSite: http.SameSiteLaxMode,
			// Secure: true, // Open in production environment
		})
	} else {
		helpers.CreateGraphQLError(ctx, "Error while setting cookie", http.StatusInternalServerError)
		return nil, nil
	}

	return &model.RegisterUserResponse{
		Message: "User registered successfully",
		User:    &dbUser,
	}, tx.Commit()
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.SignInInput) (*model.SignInResponse, error) {
	dbUser, err := dbConfig.DbCfg.Queries.GetUserByEmail(ctx, input.Email)

	if err != nil {
		if err != sql.ErrNoRows {
			helpers.CreateGraphQLError(ctx, "Error while checking if user already exists", http.StatusInternalServerError)
			return nil, nil
		} else {
			helpers.CreateGraphQLError(ctx, "User not found", http.StatusNotFound)
			return nil, nil
		}
	}

	if err := bcrypt.CompareHashAndPassword([]byte(dbUser.PasswordHash), []byte(input.Password)); err != nil {
		helpers.CreateGraphQLError(ctx, "Invalid password", http.StatusUnauthorized)
		return nil, nil
	}

	jwtInfo, err := helpers.GenerateJWT(dbUser.ID.String(), string(dbUser.Role))

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while generating JWT", http.StatusInternalServerError)
		return nil, nil
	}

	if w, ok := ctx.Value(helpers.ResponseWriterKey).(http.ResponseWriter); ok {
		http.SetCookie(w, &http.Cookie{
			Name:     "auth_token",
			Value:    jwtInfo,
			HttpOnly: true,
			Path:     "/",
			SameSite: http.SameSiteLaxMode,
			// Secure: true, // Open in production environment
		})
	} else {
		helpers.CreateGraphQLError(ctx, "Error while setting cookie", http.StatusInternalServerError)
		return nil, nil
	}

	return &model.SignInResponse{
		Message: "User registered successfully",
		User:    &dbUser,
	}, nil
}

// ConfirmUser is the resolver for the confirmUser field.
func (r *mutationResolver) ConfirmUser(ctx context.Context, input model.ConfirmUserInput) (*model.ConfirmUserResponse, error) {
	code := graphql.GetOperationContext(ctx).Variables["input"].(map[string]any)["confirmationCode"].(string)
	err := helpers.V.VarWithKey("code", code, "len=6")
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Invalid confirmation code", http.StatusBadRequest)
		return nil, nil
	}

	userContext, ok := ctx.Value(types.UserContextKey).(types.UserContext)
	if !ok {
		helpers.CreateGraphQLError(ctx, "Username check requires authentication", http.StatusUnauthorized)
		return nil, fmt.Errorf("unauthorized")
	}

	user, err := dbConfig.DbCfg.Queries.ConfirmUser(ctx, database.ConfirmUserParams{
		ID:       userContext.User.ID,
		Provider: "email",
		VerificationCode: sql.NullString{
			String: input.ConfirmationCode,
			Valid:  true,
		},
	})
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Invalid confirmation code", http.StatusBadRequest)
		return nil, nil
	}

	return &model.ConfirmUserResponse{
		Message: "User confirmed successfully",
		User:    &user,
	}, nil
}

// Username is the resolver for the username field.
func (r *userResolver) Username(ctx context.Context, obj *database.User) (*string, error) {
	if obj.Username.Valid {
		return &obj.Username.String, nil
	}
	return nil, nil
}

// Role is the resolver for the role field.
func (r *userResolver) Role(ctx context.Context, obj *database.User) (string, error) {
	return string(obj.Role), nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// User returns graph.UserResolver implementation.
func (r *Resolver) User() graph.UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
