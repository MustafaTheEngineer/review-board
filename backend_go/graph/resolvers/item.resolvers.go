package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"database/sql"
	"fmt"
	"net/http"

	handlers "github.com/MustafaTheEngineer/review_board/audit"
	dbConfig "github.com/MustafaTheEngineer/review_board/config/db"
	graph "github.com/MustafaTheEngineer/review_board/graph/generated"
	"github.com/MustafaTheEngineer/review_board/graph/model"
	"github.com/MustafaTheEngineer/review_board/helpers"
	"github.com/MustafaTheEngineer/review_board/internal/database"
	"github.com/MustafaTheEngineer/review_board/types"
	goqu "github.com/doug-martin/goqu/v9"
	"github.com/doug-martin/goqu/v9/exp"
	"github.com/google/uuid"
)

// ID is the resolver for the id field.
func (r *itemResolver) ID(ctx context.Context, obj *database.Item) (string, error) {
	return obj.ID.String(), nil
}

// CreatorID is the resolver for the creatorID field.
func (r *itemResolver) CreatorID(ctx context.Context, obj *database.Item) (string, error) {
	return obj.CreatorID.String(), nil
}

// Description is the resolver for the description field.
func (r *itemResolver) Description(ctx context.Context, obj *database.Item) (*string, error) {
	return &obj.Description.String, nil
}

// DeletedByUserID is the resolver for the deletedByUserID field.
func (r *itemResolver) DeletedByUserID(ctx context.Context, obj *database.Item) (*string, error) {
	deletedByID := obj.DeletedByUserID.UUID.String()
	var ID *string
	if !obj.DeletedByUserID.Valid {
		return ID, nil
	}
	ID = &deletedByID

	return ID, nil
}

// DeletedAt is the resolver for the deletedAt field.
func (r *itemResolver) DeletedAt(ctx context.Context, obj *database.Item) (*string, error) {
	deletedAtID := obj.DeletedAt.Time.Format("2006-01-02T15:04:05Z07:00")
	var deletedTime *string
	if !obj.DeletedAt.Valid {
		return nil, nil
	}

	deletedTime = &deletedAtID

	return deletedTime, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *itemResolver) CreatedAt(ctx context.Context, obj *database.Item) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *itemResolver) UpdatedAt(ctx context.Context, obj *database.Item) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input model.CreateItemRequest) (*model.CreateItemResponse, error) {
	userContext, ok := ctx.Value(types.UserContextKey).(types.UserContext)
	if !ok {
		helpers.CreateGraphQLError(ctx, "User token is not set", http.StatusUnauthorized)
		return nil, nil
	}

	tx, err := dbConfig.DbCfg.SqlDb.Begin()

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while starting transaction", http.StatusInternalServerError)
		return nil, err
	}
	defer tx.Rollback()

	qtx := dbConfig.DbCfg.Queries.WithTx(tx)

	_, err = qtx.SelectUserItem(ctx, database.SelectUserItemParams{
		CreatorID: userContext.User.ID,
		Title:     input.Title,
	})

	if err == nil {
		helpers.CreateGraphQLError(ctx, "User already has an item with this title", http.StatusConflict)
		return nil, nil
	} else {
		if err != sql.ErrNoRows {
			helpers.CreateGraphQLError(ctx, "Error while checking user item", http.StatusConflict)
			return nil, nil
		}
	}

	itemID := uuid.New()
	dbItem, err := qtx.InsertItem(ctx, database.InsertItemParams{
		ID:        itemID,
		CreatorID: userContext.User.ID,
		Title:     input.Title,
		Description: sql.NullString{
			String: func() string {
				if input.Description == nil {
					return ""
				}
				return *input.Description

			}(),
			Valid: input.Description != nil,
		},
		Amount: fmt.Sprintf("%f", input.Amount),
		Status: "NEW",
	})

	if err != nil {
		helpers.CreateGraphQLError(ctx, err.Error(), http.StatusInternalServerError)
		return nil, nil

	}

	message := "Item Created"

	err = handlers.InsertAuditLog(
		qtx,
		ctx,
		handlers.Log[database.Item]{
			UserID:      userContext.User.ID,
			UserEmail:   userContext.User.Email,
			UserRole:    userContext.User.Role,
			EntityType:  "ITEM",
			EntityID:    dbItem.ID,
			Action:      database.AuditActionCREATE,
			OldValues:   nil,
			NewValues:   &dbItem,
			Description: &message,
		})

	if err != nil {
		helpers.CreateGraphQLError(ctx, err.Error(), http.StatusInternalServerError)
		return nil, nil
	}

	tags := make([]string, 0, len(input.Tags))
	for _, tag := range input.Tags {
		dbTag, err := qtx.SelectTagByName(ctx, tag)
		if err != nil {
			if err != sql.ErrNoRows {
				helpers.CreateGraphQLError(ctx, "Error while selecting tag", http.StatusInternalServerError)
				return nil, nil
			} else {
				newDbTag, err := qtx.InsertTag(ctx, database.InsertTagParams{
					ID: uuid.New(),
					CreatedByUserID: uuid.NullUUID{
						UUID:  userContext.User.ID,
						Valid: true,
					},
					Name: tag,
				})
				if err != nil {
					helpers.CreateGraphQLError(ctx, "Error while inserting tag", http.StatusInternalServerError)
					return nil, nil
				}
				dbTag = newDbTag
			}
		}

		_, err = qtx.InsertItemTag(ctx, database.InsertItemTagParams{
			ItemID: dbItem.ID,
			TagID:  dbTag.ID,
		})
		if err != nil {
			helpers.CreateGraphQLError(ctx, "Error while inserting item_tag", http.StatusInternalServerError)
			return nil, err
		}
		tags = append(tags, dbTag.Name)
	}

	return &model.CreateItemResponse{
		Item: &dbItem,
		Tags: tags,
	}, tx.Commit()
}

// UpdateItemStatus is the resolver for the updateItemStatus field.
func (r *mutationResolver) UpdateItemStatus(ctx context.Context, id string, status database.ItemStatus) (*database.Item, error) {
	userContext, ok := ctx.Value(types.UserContextKey).(types.UserContext)
	if !ok {
		helpers.CreateGraphQLError(ctx, "User token is not set", http.StatusUnauthorized)
		return nil, nil
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Invalid item ID", http.StatusBadRequest)
		return nil, nil
	}

	tx, err := dbConfig.DbCfg.SqlDb.Begin()

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while starting transaction", http.StatusInternalServerError)
		return nil, err
	}
	defer tx.Rollback()

	qtx := dbConfig.DbCfg.Queries.WithTx(tx)

	dbItem, err := qtx.UpdateItemStatus(ctx, database.UpdateItemStatusParams{
		ID:     uid,
		Status: status,
	})
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while updating item status", http.StatusInternalServerError)
		return nil, nil
	}

	message := "Item Status Updated"

	err = handlers.InsertAuditLog(
		qtx,
		ctx,
		handlers.Log[database.Item]{
			UserID:      userContext.User.ID,
			UserEmail:   userContext.User.Email,
			UserRole:    userContext.User.Role,
			EntityType:  "ITEM",
			EntityID:    dbItem.ID,
			Action:      database.AuditActionCREATE,
			OldValues:   nil,
			NewValues:   &dbItem,
			Description: &message,
		})

	if err != nil {
		helpers.CreateGraphQLError(ctx, err.Error(), http.StatusInternalServerError)
		return nil, nil
	}

	return &dbItem, nil
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context, query *model.ItemsRequest) ([]*model.ItemsResponse, error) {
	queryTags := goqu.Select("*").From("items")
	expressions := make([]exp.Expression, 0)

	if query == nil {
		queryTags = queryTags.Limit(100)
	} else {
		if len(query.Users) > 0 {
			expressions = append(expressions, goqu.C("creator_id").In(query.Users))
		}
		if len(query.Tags) > 0 {
			tag := goqu.Select("item_id").From("item_tags").Where(goqu.C("tag_id").In(query.Tags))

			expressions = append(expressions, goqu.C("id").In(tag))
		}
		if len(query.Statuses) > 0 {
			expressions = append(expressions, goqu.C("status").In(query.Statuses))
		}
		if query.Like != nil {
			expressions = append(expressions, goqu.C("title").Like("%"+*query.Like+"%"))
		}
		if query.Limit == nil {
			queryTags = queryTags.Limit(100)
		} else {
			queryTags = queryTags.Limit(uint(*query.Limit))
		}
		if query.Offset != nil {
			queryTags = queryTags.Offset(uint(*query.Offset))
		}

		if len(expressions) > 0 {
			queryTags = queryTags.Where(goqu.And(expressions...))
		}
	}

	querySQL, _, err := queryTags.ToSQL()
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while fetching items", http.StatusInternalServerError)
		return nil, nil
	}

	tx, err := dbConfig.DbCfg.SqlDb.Begin()

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while starting transaction", http.StatusInternalServerError)
		return nil, err
	}
	defer tx.Rollback()

	qtx := dbConfig.DbCfg.Queries.WithTx(tx)

	dbItems, err := tx.Query(querySQL)
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while fetching items", http.StatusInternalServerError)
		return nil, nil
	}

	var items []*model.ItemsResponse

	for dbItems.Next() {
		var item database.Item
		err := dbItems.Scan(
			&item.ID,
			&item.CreatorID,
			&item.Title,
			&item.Description,
			&item.Amount,
			&item.RiskScore,
			&item.Status,
			&item.DeletedByUserID,
			&item.DeletedAt,
			&item.CreatedAt,
			&item.UpdatedAt,
		)
		if err != nil {
			helpers.CreateGraphQLError(ctx, "Error while scanning item", http.StatusInternalServerError)
			return nil, nil
		}

		items = append(items, &model.ItemsResponse{
			Item: &item,
		})
	}
	dbItems.Close()

	for _, item := range items {
		var tags []*database.Tag
		dbTags, err := qtx.SelectItemTags(ctx, item.Item.ID)
		if err != nil {
			helpers.CreateGraphQLError(ctx, err.Error(), http.StatusInternalServerError)
			return nil, nil
		}

		for _, dbTag := range dbTags {
			tags = append(tags, &database.Tag{
				ID:   dbTag.ID,
				Name: dbTag.Name,
			})
		}

		item.Tags = tags
	}

	return items, tx.Commit()
}

// Item is the resolver for the item field.
func (r *queryResolver) Item(ctx context.Context, id string) (*database.Item, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Invalid item ID", http.StatusBadRequest)
		return nil, nil
	}

	dbItem, err := dbConfig.DbCfg.Queries.ItemById(ctx, uid)
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while fetching item", http.StatusInternalServerError)
		return nil, nil
	}

	return &dbItem, nil
}

// Item returns graph.ItemResolver implementation.
func (r *Resolver) Item() graph.ItemResolver { return &itemResolver{r} }

type itemResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *itemResolver) RiskScore(ctx context.Context, obj *database.Item) (int32, error) {
	return obj.RiskScore, nil
}
*/
