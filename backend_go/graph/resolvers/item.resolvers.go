package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"database/sql"
	"fmt"
	"net/http"

	dbConfig "github.com/MustafaTheEngineer/review_board/config/db"
	graph "github.com/MustafaTheEngineer/review_board/graph/generated"
	"github.com/MustafaTheEngineer/review_board/graph/model"
	"github.com/MustafaTheEngineer/review_board/helpers"
	"github.com/MustafaTheEngineer/review_board/internal/database"
	"github.com/MustafaTheEngineer/review_board/types"
	"github.com/google/uuid"
)

// ID is the resolver for the id field.
func (r *itemResolver) ID(ctx context.Context, obj *database.Item) (string, error) {
	return obj.ID.String(), nil
}

// Description is the resolver for the description field.
func (r *itemResolver) Description(ctx context.Context, obj *database.Item) (*string, error) {
	return &obj.Description.String, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *itemResolver) CreatedAt(ctx context.Context, obj *database.Item) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *itemResolver) UpdatedAt(ctx context.Context, obj *database.Item) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input model.CreateItemRequest) (*model.CreateItemResponse, error) {
	userContext, ok := ctx.Value(types.UserContextKey).(types.UserContext)
	if !ok {
		helpers.CreateGraphQLError(ctx, "User token is not set", http.StatusUnauthorized)
		return nil, nil
	}

	tx, err := dbConfig.DbCfg.SqlDb.Begin()

	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while starting transaction", http.StatusInternalServerError)
		return nil, err
	}
	defer tx.Rollback()

	qtx := dbConfig.DbCfg.Queries.WithTx(tx)

	_, err = qtx.SelectUserItem(ctx, database.SelectUserItemParams{
		CreatorID: userContext.User.ID,
		Title:     input.Title,
	})

	if err == nil {
		helpers.CreateGraphQLError(ctx, "User already has an item with this title", http.StatusConflict)
		return nil, nil
	} else {
		if err != sql.ErrNoRows {
			helpers.CreateGraphQLError(ctx, "Error while checking user item", http.StatusConflict)
			return nil, nil
		}
	}

	itemID := uuid.New()
	dbItem, err := qtx.InsertItem(ctx, database.InsertItemParams{
		ID:        itemID,
		CreatorID: userContext.User.ID,
		Title:     input.Title,
		Description: sql.NullString{
			String: func() string {
				if input.Description == nil {
					return ""
				}
				return *input.Description

			}(),
			Valid: input.Description != nil,
		},
		Amount: fmt.Sprintf("%f", input.Amount),
		Status: "new",
	})
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while inserting item", http.StatusInternalServerError)
		return nil, nil
	}

	tags := make([]string, 0, len(input.Tags))
	for _, tag := range input.Tags {
		dbTag, err := qtx.SelectTagByName(ctx, tag)
		if err != nil {
			if err != sql.ErrNoRows {
				helpers.CreateGraphQLError(ctx, "Error while selecting tag", http.StatusInternalServerError)
				return nil, nil
			} else {
				newDbTag, err := qtx.InsertTag(ctx, database.InsertTagParams{
					ID: uuid.New(),
					CreatedByUserID: uuid.NullUUID{
						UUID:  userContext.User.ID,
						Valid: true,
					},
					Name: tag,
				})
				if err != nil {
					helpers.CreateGraphQLError(ctx, "Error while inserting tag", http.StatusInternalServerError)
					return nil, nil
				}
				dbTag = newDbTag
			}
		}

		_, err = qtx.InsertItemTag(ctx, database.InsertItemTagParams{
			ItemID: dbItem.ID,
			TagID:  dbTag.ID,
		})
		if err != nil {
			helpers.CreateGraphQLError(ctx, "Error while inserting item_tag", http.StatusInternalServerError)
			return nil, err
		}
		tags = append(tags, dbTag.Name)
	}

	return &model.CreateItemResponse{
		Item: &dbItem,
		Tags: tags,
	}, tx.Commit()
}

// Item returns graph.ItemResolver implementation.
func (r *Resolver) Item() graph.ItemResolver { return &itemResolver{r} }

type itemResolver struct{ *Resolver }
