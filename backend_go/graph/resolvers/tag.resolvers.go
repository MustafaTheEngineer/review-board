package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"net/http"

	dbConfig "github.com/MustafaTheEngineer/review_board/config/db"
	graph "github.com/MustafaTheEngineer/review_board/graph/generated"
	"github.com/MustafaTheEngineer/review_board/graph/model"
	"github.com/MustafaTheEngineer/review_board/helpers"
	"github.com/MustafaTheEngineer/review_board/internal/database"
	goqu "github.com/doug-martin/goqu/v9"
)

// Tags is the resolver for the tags field.
func (r *queryResolver) Tags(ctx context.Context, query *model.TagsInput) ([]*database.Tag, error) {
	queryTags := goqu.Select("*").From("tags")
	if query == nil {
		queryTags = queryTags.Limit(10)
	} else {
		if query.Like != nil {
			queryTags = queryTags.Where(goqu.C("name").Like("%" + *query.Like + "%"))
		}
		if query.Limit == nil {
			queryTags = queryTags.Limit(10)
		} else {
			queryTags = queryTags.Limit(uint(*query.Limit))
		}
		if query.Offset != nil {
			queryTags = queryTags.Offset(uint(*query.Offset))
		}
	}

	var tags []*database.Tag
	querySQL, _, err := queryTags.ToSQL()
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while fetching tags", http.StatusInternalServerError)
		return nil, nil
	}

	dbTags, err := dbConfig.DbCfg.SqlDb.Query(querySQL)
	if err != nil {
		helpers.CreateGraphQLError(ctx, "Error while fetching tags", http.StatusInternalServerError)
		return nil, nil
	}
	defer dbTags.Close()

	for dbTags.Next() {
		var tag database.Tag
		err := dbTags.Scan(
			&tag.ID,
			&tag.CreatedByUserID,
			&tag.Name,
			&tag.CreatedAt,
			&tag.UpdatedAt,
		)
		if err != nil {
			helpers.CreateGraphQLError(ctx, "Error while scanning tag", http.StatusInternalServerError)
			return nil, nil
		}
		tags = append(tags, &tag)
	}

	if err = dbTags.Err(); err != nil {
		helpers.CreateGraphQLError(ctx, "Error while fetching tags", http.StatusInternalServerError)
		return nil, nil
	}

	return tags, nil
}

// ID is the resolver for the id field.
func (r *tagResolver) ID(ctx context.Context, obj *database.Tag) (string, error) {
	return obj.ID.String(), nil
}

// Tag returns graph.TagResolver implementation.
func (r *Resolver) Tag() graph.TagResolver { return &tagResolver{r} }

type tagResolver struct{ *Resolver }
